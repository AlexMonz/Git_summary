<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GIT-SUMMARY</title>
  </head>
  <body>
    <h1>GIT SUMMARY</h1>
    <h2>COMANDS AND EXAMPLES1</h2>
    <h2>git init</h2>
    <p>
      git init es un comando que se utiliza una sola vez durante la
      configuración inicial de un repositorio nuevo. Al ejecutar este comando,
      se creará un nuevo subdirectorio . git en tu directorio de trabajo actual.
      También se creará una nueva rama principal.
    </p>
    <h2>git status</h2>
    <p>
      El comando git status muestra el estado del directorio de trabajo y del
      área del entorno de ensayo. Permite ver los cambios que se han preparado,
      los que no y los archivos en los que Git no va a realizar el seguimiento.
      El resultado del estado no muestra ninguna información relativa al
      historial del proyecto.
    </p>
    <h2>git add y el staged area</h2>
    <p>
      - git add: El comando git add añade un cambio del directorio de trabajo en el entorno
      de ensayo. De este modo, indica a Git que quieres incluir actualizaciones
      en un archivo concreto en la próxima confirmación. 
      - Staged area: es el
      lugar en el que se encuentran datos de un proyecto y sus cambios. En esta
      área puedes asignarle un nombre a una nueva versión y crear una “copia” de
      cómo quedaría dicha versión en el repositorio en producción.
    </p>
    <h2>git add</h2>
    <p>
      El comando git add añade un cambio del directorio de trabajo en el entorno
      de ensayo. De este modo, indica a Git que quieres incluir actualizaciones
      en un archivo concreto en la próxima confirmación.
    </p>
    <h2>git add .</h2>
    <p>
      Este comando añade al índice cualquier fichero nuevo o que haya sido
      modificado:
    </p>
    <h2>git add -u / git add -n / git add -a</h2>
    <p>
      <ul>
        <li>git add -u: La opción -u sólo añade al índice aquellos ficheros que ya
          estén siendo monitorizados por git.</li>
        <li>git add -n: Esta opción es muy
          práctica ya que nos mostrará en pantalla lo que el comando git-add haría
          sin actualizar el índice.</li>
        <li>git add -a: Esta opción funciona como la
          opción -u añadiendo también a la búsqueda los ficheros del área de
          trabajo. El resultado es que los ficheros que no estén siendo
          monitorizados también se añadirán al índice.</li>
      </ul>
       - git add -a: Esta opción funciona como la
      opción -u añadiendo también a la búsqueda los ficheros del área de
      trabajo. El resultado es que los ficheros que no estén siendo
      monitorizados también se añadirán al índice.
    </p>
    <h2>git commit</h2>
    <p>
    - git commit -m "Este es el primer commit"
    </p>
    <h2>git log</h2>
    <p>
      El comando git log muestra todas las commits en el historial del repositorio.
      Por defecto, el comando muestra los datos de cada commit:
      <ul>
        <li>Secure Hash Algorithm (SHA)</li>
        <li>Autor</li>
        <li>Fecha</li>
        <li>Mensaje del commit</li>
      </ul>
    </p>
    <h3>Options</h3>
    <ul>
      <li>git log --oneline: muestra el log resumido en una linea por evento.</li>
      <li>git log --stat</li>
      <li>git log --patch</li>
      <li>git log -p</li>
      <li>git log --graph</li>
    </ul>
    <h2>git checkout</h2>
    <p>
      <ul>
        <li>git checkout -b [Nombre de la Rama]: crea una rama </li>
        <li></li>
      </ul>
    </p>
    <h2>git diff</h2>
    <p>
      git diff es un comando multiusos de Git que, cuando se ejecuta, lleva a cabo una 
      función para establecer las diferencias en los orígenes de datos de Git. 
      Dichos orígenes de datos pueden ser confirmaciones, ramas y archivos, entre otras posibilidades.
    </p>
    <h2>git branch</h2>
    <p>
      El comando git branch permite crear una rama nueva. 
      Si quieres empezar a trabajar en una nueva función, puedes crear una rama nueva a partir de la 
      rama main con git branch new_branch. Una vez creada, puedes usar git checkout new_branch para 
      cambiar a esa rama. Además, el comando git checkout acepta el argumento -b, que actúa como un 
      práctico método que creará la nueva rama y cambiará a ella al instante. Puedes trabajar en varias 
      funciones en un solo repositorio alternando de una a otra con git checkout.
      <h3>Options</h3>
      <ul>
        <li>git branch -a : Revisa el nombre de tu rama corriendo</li>
        <li>git branch -m : Cambiar de nombre la rama ej: git branch - m nuevoNombre</li>
        <li>git branch -d : Borrar la rama - git branch - d nombreRamaAborrar</li>
        <li>git branch -d : Borrar la rama - git branch - d nombreRamaAborrar</li>
        <li>git branch -D [nombreRamaAborar]: Borrar la rama aunque haya cambios en ella que no esten comiteados.</li>
      </ul>
    </p>
    <h2>git merge</h2>
    <ul>
      <li>git merge master: se trae todos los cambios de master a la rama en la que estes.</li>
    </ul>
    <p>fast-foward: git switch master / git merge nombreRama</p>
    <p>
      Unir dos ramas lo conocemos como Merge. El comando git merge permite tomar las líneas independientes de desarrollo creadas por git branch e integrarlas en una sola rama. 
      Ten en cuenta que todos los comandos presentados a continuación se fusionan en la rama actual.
    </p>
    <h2>git rebase</h2>
    <p>Si prefieres un historial limpio, lineal y libre de commits de fusión innecesarios,
       debes usar el comando git rebase en lugar de git merge para integrar los cambios de otra rama.</p>
    <h2>git stwich</h2>
    <p>
  
    </p>
    <h2>git push</h2>
    <p>El comando git push se usa para cargar contenido del repositorio local a un repositorio remoto. 
      El envío es la forma de transferir confirmaciones desde tu repositorio local a un repositorio remoto.</p>
    <ul>
      <li>git push --help</li>
      <li>git push name -f: </li>
      <li>git push origin [Nombre de la Rama]: </li>
      <li>git push Origin localBranchName:remoteBranchName: Cuando el nombre de su sucursal local y remota es diferente </li>
      <li>git Push Origin branchName: Si su sucursal local y su sucursal remota tienen el mismo nombre </li>
      <li>git Push Origin AMD_qlp_teste: Empuje a la sucursal ubicada en Origen llamada AMD_qlp_tester </li>
      <li>git Push -u Origin AMD_qlp_tester: igual que el anterior, pero establece el enlace ascendente que une la sucursal local con la sucursal remota para que 
        la próxima vez pueda usar git Push/pull si no está ya vinculado (solo debe hacerlo una vez).</li>
    </ul>
    <h2>git remote</h2>
    <p>
      <ul>
        <li>git remote [Nombre del repositorio]: muestra la rama origen remota</li>
        <li>git remote -v: Esto hace algo de magia usando git pull y git push para garantizar que el contenido de tu nuevo repositorio de Github y la carpeta en tu sistema local sean los mismos. </li>
        <li>git remote add origin [https://github.com/nombreDeUsuario/repositorio.git]: nombreDeUsuario y repositorio serán reemplazados por los valores proporcionados en el enlace copiado. Esto conectará la carpeta existente en tu sistema local al repositorio de Github recién creado. </li>
        <li>git remote add upstream [HTTPS]: Aquí, [HTTPS] es el URL que debes copiar del repositorio del propietario. Para poder extraer los cambios desde el repositorio original a tu versión local, necesitas agregar el repositorio Git original como un repositorio upstream. </li>
      </ul>

    Para ver las ramas remotas existentes.
    </p>
    <h2>git fetch</h2>
    <p>
      es el comando que le dice a tu git local que recupere la última información de los metadatos del original (aunque no hace ninguna transferencia de archivos. 
      Es más bien como comprobar si hay algún cambio disponible).</p>
      <p>Puedes usar git fetch para saber los cambios hechos en el repo/rama remoto desde tu último pull. Esto es útil para permitir la comprobación antes de hacer un pull real, 
      lo que podría cambiar los archivos en tu rama actual y en la copia de trabajo (y potencialmente perder tus cambios, etc.).</p>
    </p>
    <h2>git pull</h2>
    <p>
      
    </p>
    <h2>git revert</h2>
    <p>
      
    </p>

  </body>
</html>
